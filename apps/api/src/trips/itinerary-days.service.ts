/**
 * Itinerary Days Service
 *
 * Business logic for managing itinerary days.
 * Days are created from trip start/end dates and can be reordered.
 */

import { Injectable, NotFoundException, BadRequestException, Logger } from '@nestjs/common'
import { eq, ne, and, desc, asc, inArray, sql } from 'drizzle-orm'
import { DatabaseService } from '../db/database.service'
import type { PgTransaction } from 'drizzle-orm/pg-core'
import type {
  ItineraryDayResponseDto,
  ItineraryDayWithActivitiesDto,
  CreateItineraryDayDto,
  UpdateItineraryDayDto,
  ReorderDaysDto,
  AutoGenerateDaysDto,
  BatchCreateDaysDto,
} from '@tailfire/shared-types'

@Injectable()
export class ItineraryDaysService {
  private readonly logger = new Logger(ItineraryDaysService.name)

  constructor(private readonly db: DatabaseService) {}

  /**
   * Get all days for an itinerary, ordered by sequence
   */
  async findAll(itineraryId: string): Promise<ItineraryDayResponseDto[]> {
    const days = await this.db.client
      .select()
      .from(this.db.schema.itineraryDays)
      .where(eq(this.db.schema.itineraryDays.itineraryId, itineraryId))
      .orderBy(asc(this.db.schema.itineraryDays.sequenceOrder))

    return days.map(this.formatDayResponse)
  }

  /**
   * Get all days with nested activities.
   * Note: Activities include both activityType (canonical) and componentType (deprecated)
   * via the spread for backward compatibility.
   */
  async findAllWithActivities(itineraryId: string): Promise<ItineraryDayWithActivitiesDto[]> {
    const days = await this.db.client.query.itineraryDays.findMany({
      where: eq(this.db.schema.itineraryDays.itineraryId, itineraryId),
      with: {
        activities: {
          orderBy: asc(this.db.schema.itineraryActivities.sequenceOrder),
        },
      },
      orderBy: asc(this.db.schema.itineraryDays.sequenceOrder),
    })

    // Collect all activity IDs and cruise activity IDs across all days
    const allActivityIds: string[] = []
    const cruiseActivityIds: string[] = []
    for (const day of days) {
      for (const activity of day.activities) {
        allActivityIds.push(activity.id)
        if (activity.activityType === 'custom_cruise') {
          cruiseActivityIds.push(activity.id)
        }
      }
    }

    // Fetch thumbnails from activity_media for all activities
    // Also fetch ship images for cruise activities as fallback
    const [thumbnailMap, shipImageMap] = await Promise.all([
      this.fetchThumbnails(allActivityIds),
      this.fetchCruiseShipImages(cruiseActivityIds),
    ])

    return days.map((day) => ({
      ...this.formatDayResponse(day),
      activities: day.activities.map((activity) => {
        // Determine thumbnail: first check activity_media (from thumbnailMap),
        // then fall back to photos array, then ship image for cruise activities
        const mediaThumbnail = thumbnailMap.get(activity.id) || null
        const photosThumbnail = activity.photos?.[0]?.url || null
        const shipImageThumbnail = shipImageMap.get(activity.id) || null
        const thumbnail = mediaThumbnail || photosThumbnail || shipImageThumbnail

        return {
          // Spread includes activityType (canonical) and componentType (deprecated)
          ...activity,
          parentActivityId: activity.parentActivityId || null,
          description: activity.description || null,
          startDatetime: activity.startDatetime?.toISOString() || null,
          endDatetime: activity.endDatetime?.toISOString() || null,
          timezone: activity.timezone || null,
          location: activity.location || null,
          address: activity.address || null,
          coordinates: activity.coordinates || null,
          notes: activity.notes || null,
          confirmationNumber: activity.confirmationNumber || null,
          status: activity.status || 'proposed',
          isBooked: activity.isBooked ?? false,
          bookingDate: activity.bookingDate?.toISOString() || null,
          packageId: null, // Deprecated: use parentActivityId for package relationships
          pricing: null, // Pricing comes from activity_pricing table
          pricingType: activity.pricingType || null,
          currency: activity.currency || 'USD',
          photos: activity.photos || null,
          thumbnail,
          createdAt: activity.createdAt.toISOString(),
          updatedAt: activity.updatedAt.toISOString(),
        }
      }),
    }))
  }

  /**
   * Batch fetch thumbnails from activity_media for given activity IDs
   * Returns a map of activityId -> first image URL
   */
  private async fetchThumbnails(activityIds: string[]): Promise<Map<string, string>> {
    if (activityIds.length === 0) return new Map()

    // Fetch first image for each activity (ordered by orderIndex)
    const mediaRecords = await this.db.client
      .select({
        activityId: this.db.schema.activityMedia.activityId,
        fileUrl: this.db.schema.activityMedia.fileUrl,
        orderIndex: this.db.schema.activityMedia.orderIndex,
      })
      .from(this.db.schema.activityMedia)
      .where(
        and(
          inArray(this.db.schema.activityMedia.activityId, activityIds),
          eq(this.db.schema.activityMedia.mediaType, 'image')
        )
      )
      .orderBy(asc(this.db.schema.activityMedia.orderIndex))

    // Create a map of activityId -> first image URL
    const thumbnailMap = new Map<string, string>()
    for (const record of mediaRecords) {
      // Only set if we don't already have a thumbnail for this activity (first one wins)
      if (!thumbnailMap.has(record.activityId)) {
        thumbnailMap.set(record.activityId, record.fileUrl)
      }
    }

    return thumbnailMap
  }

  /**
   * Batch fetch ship images from custom_cruise_details for cruise activity IDs
   * Returns a map of activityId -> ship image URL
   */
  private async fetchCruiseShipImages(cruiseActivityIds: string[]): Promise<Map<string, string>> {
    if (cruiseActivityIds.length === 0) return new Map()

    const cruiseDetails = await this.db.client
      .select({
        activityId: this.db.schema.customCruiseDetails.activityId,
        shipImageUrl: this.db.schema.customCruiseDetails.shipImageUrl,
      })
      .from(this.db.schema.customCruiseDetails)
      .where(inArray(this.db.schema.customCruiseDetails.activityId, cruiseActivityIds))

    const shipImageMap = new Map<string, string>()
    for (const record of cruiseDetails) {
      if (record.shipImageUrl) {
        shipImageMap.set(record.activityId, record.shipImageUrl)
      }
    }

    return shipImageMap
  }

  /**
   * Find a day by date, or create it if it doesn't exist.
   * Used for generating cruise port schedules where days may not yet exist.
   */
  async findOrCreateByDate(itineraryId: string, date: string): Promise<ItineraryDayResponseDto> {
    // Get agencyId from itinerary (needed for RLS if creating new day)
    const [itinerary] = await this.db.client
      .select({ agencyId: this.db.schema.itineraries.agencyId })
      .from(this.db.schema.itineraries)
      .where(eq(this.db.schema.itineraries.id, itineraryId))
      .limit(1)

    if (!itinerary?.agencyId) {
      throw new NotFoundException(`Itinerary ${itineraryId} not found or has no agency`)
    }

    const agencyId = itinerary.agencyId

    // First, try to find existing day by date
    const [existingDay] = await this.db.client
      .select()
      .from(this.db.schema.itineraryDays)
      .where(
        and(
          eq(this.db.schema.itineraryDays.itineraryId, itineraryId),
          eq(this.db.schema.itineraryDays.date, date)
        )
      )
      .limit(1)

    if (existingDay) {
      return this.formatDayResponse(existingDay)
    }

    // Day doesn't exist - create it
    // First, get existing days to determine day number and sequence
    const existingDays = await this.db.client
      .select()
      .from(this.db.schema.itineraryDays)
      .where(eq(this.db.schema.itineraryDays.itineraryId, itineraryId))
      .orderBy(asc(this.db.schema.itineraryDays.dayNumber))

    // Calculate day number based on date ordering
    const dateObj = new Date(date)
    let dayNumber = 1
    let sequenceOrder = 0

    if (existingDays.length > 0) {
      // Find the correct position for this date
      const daysWithDates = existingDays.filter(d => d.date)
      let insertIndex = daysWithDates.length

      for (let i = 0; i < daysWithDates.length; i++) {
        const day = daysWithDates[i]
        if (!day) continue
        const existingDate = new Date(day.date as string)
        if (dateObj < existingDate) {
          insertIndex = i
          break
        }
      }

      // Calculate day number and sequence based on position
      if (insertIndex === 0) {
        dayNumber = 1
        sequenceOrder = 0
      } else {
        const maxDayNumber = Math.max(...existingDays.map(d => d.dayNumber))
        dayNumber = maxDayNumber + 1
        const maxSequence = Math.max(...existingDays.map(d => d.sequenceOrder))
        sequenceOrder = maxSequence + 1
      }
    }

    // Format date for title
    const formattedDate = dateObj.toLocaleDateString('en-US', {
      weekday: 'short',
      month: 'short',
      day: 'numeric',
    })

    const [day] = await this.db.client
      .insert(this.db.schema.itineraryDays)
      .values({
        agencyId,
        itineraryId,
        dayNumber,
        date,
        title: `Day ${dayNumber} - ${formattedDate}`,
        sequenceOrder,
      })
      .returning()

    return this.formatDayResponse(day)
  }

  /**
   * Bulk find or create multiple days by date range.
   * Uses INSERT ... ON CONFLICT DO NOTHING for idempotent upsert.
   * This is optimized for cruise port schedule generation where multiple days
   * need to be created atomically.
   *
   * @param itineraryId - The itinerary to add days to
   * @param dates - Array of date strings (YYYY-MM-DD format)
   * @param tx - Optional transaction context (for use within larger transactions)
   * @returns Array of day records (both pre-existing and newly created)
   */
  async findOrCreateByDateRange(
    itineraryId: string,
    dates: string[],
    tx?: PgTransaction<any, any, any>
  ): Promise<ItineraryDayResponseDto[]> {
    const start = Date.now()

    if (dates.length === 0) {
      return []
    }

    const db = tx || this.db.client

    // Get agencyId from itinerary (needed for RLS on inserts)
    const [itinerary] = await db
      .select({ agencyId: this.db.schema.itineraries.agencyId })
      .from(this.db.schema.itineraries)
      .where(eq(this.db.schema.itineraries.id, itineraryId))
      .limit(1)

    if (!itinerary?.agencyId) {
      throw new NotFoundException(`Itinerary ${itineraryId} not found or has no agency`)
    }

    const agencyId = itinerary.agencyId

    // Get max day number and sequence order for new days
    const existingDays = await db
      .select({
        dayNumber: this.db.schema.itineraryDays.dayNumber,
        sequenceOrder: this.db.schema.itineraryDays.sequenceOrder,
      })
      .from(this.db.schema.itineraryDays)
      .where(eq(this.db.schema.itineraryDays.itineraryId, itineraryId))

    const maxDayNumber = existingDays.length > 0
      ? Math.max(...existingDays.map(d => d.dayNumber))
      : 0
    const maxSequenceOrder = existingDays.length > 0
      ? Math.max(...existingDays.map(d => d.sequenceOrder))
      : -1

    // Prepare bulk insert values
    // Sort dates to ensure sequential day numbering
    const sortedDates = [...dates].sort((a, b) => new Date(a).getTime() - new Date(b).getTime())

    const valuesToInsert = sortedDates.map((dateStr, idx) => {
      const dateObj = new Date(dateStr)
      const formattedDate = dateObj.toLocaleDateString('en-US', {
        weekday: 'short',
        month: 'short',
        day: 'numeric',
      })
      const dayNum = maxDayNumber + idx + 1

      return {
        agencyId,
        itineraryId,
        dayNumber: dayNum,
        date: dateStr,
        title: `Day ${dayNum} - ${formattedDate}`,
        sequenceOrder: maxSequenceOrder + idx + 1,
      }
    })

    // Bulk INSERT with ON CONFLICT DO NOTHING
    // Uses the partial unique index on (itinerary_id, date) WHERE date IS NOT NULL
    await db
      .insert(this.db.schema.itineraryDays)
      .values(valuesToInsert)
      .onConflictDoNothing()

    // SELECT all days for the requested dates (includes pre-existing + just-created)
    const allDays = await db
      .select()
      .from(this.db.schema.itineraryDays)
      .where(
        and(
          eq(this.db.schema.itineraryDays.itineraryId, itineraryId),
          inArray(this.db.schema.itineraryDays.date, sortedDates)
        )
      )
      .orderBy(asc(this.db.schema.itineraryDays.date))

    const duration = Date.now() - start
    // Use debug level for performance metrics to avoid noise in production logs
    this.logger.debug({
      message: 'Bulk day upsert completed',
      event: 'bulk_day_upsert_ms',
      duration,
      dayCount: dates.length,
      itineraryId,
      createdCount: valuesToInsert.length,
      returnedCount: allDays.length,
    })

    return allDays.map(this.formatDayResponse)
  }

  /**
   * Get a single day by ID
   */
  async findOne(id: string): Promise<ItineraryDayResponseDto> {
    const [day] = await this.db.client
      .select()
      .from(this.db.schema.itineraryDays)
      .where(eq(this.db.schema.itineraryDays.id, id))
      .limit(1)

    if (!day) {
      throw new NotFoundException(`Itinerary day with ID ${id} not found`)
    }

    return this.formatDayResponse(day)
  }

  /**
   * Create a new day
   */
  async create(dto: CreateItineraryDayDto): Promise<ItineraryDayResponseDto> {
    // Get itinerary to verify it exists and retrieve agencyId
    const [itinerary] = await this.db.client
      .select({ agencyId: this.db.schema.itineraries.agencyId })
      .from(this.db.schema.itineraries)
      .where(eq(this.db.schema.itineraries.id, dto.itineraryId))
      .limit(1)

    if (!itinerary?.agencyId) {
      throw new NotFoundException(`Itinerary with ID ${dto.itineraryId} not found`)
    }

    const agencyId = itinerary.agencyId

    // Check for duplicate day number within the itinerary
    const existing = await this.db.client
      .select()
      .from(this.db.schema.itineraryDays)
      .where(
        and(
          eq(this.db.schema.itineraryDays.itineraryId, dto.itineraryId),
          eq(this.db.schema.itineraryDays.dayNumber, dto.dayNumber)
        )
      )
      .limit(1)

    if (existing.length > 0) {
      throw new BadRequestException(
        `Day ${dto.dayNumber} already exists for this itinerary`
      )
    }

    // If no sequence order provided, get the next available
    let sequenceOrder = dto.sequenceOrder ?? 0
    if (dto.sequenceOrder === undefined) {
      const maxSeq = await this.getMaxSequenceOrder(dto.itineraryId)
      sequenceOrder = maxSeq + 1
    }

    const [day] = await this.db.client
      .insert(this.db.schema.itineraryDays)
      .values({
        agencyId,
        itineraryId: dto.itineraryId,
        dayNumber: dto.dayNumber,
        date: dto.date || null,
        title: dto.title || null,
        notes: dto.notes || null,
        sequenceOrder,
      })
      .returning()

    return this.formatDayResponse(day)
  }

  /**
   * Update a day
   */
  async update(id: string, dto: UpdateItineraryDayDto): Promise<ItineraryDayResponseDto> {
    // Check if day exists
    const existing = await this.findOne(id)

    // If updating day number, check for conflicts
    if (dto.dayNumber !== undefined && dto.dayNumber !== existing.dayNumber) {
      const conflict = await this.db.client
        .select()
        .from(this.db.schema.itineraryDays)
        .where(
          and(
            eq(this.db.schema.itineraryDays.itineraryId, existing.itineraryId),
            eq(this.db.schema.itineraryDays.dayNumber, dto.dayNumber),
            // Exclude current day from check
            ne(this.db.schema.itineraryDays.id, id)
          )
        )
        .limit(1)

      if (conflict.length > 0) {
        throw new BadRequestException(
          `Day ${dto.dayNumber} already exists for this itinerary`
        )
      }
    }

    const [day] = await this.db.client
      .update(this.db.schema.itineraryDays)
      .set({
        ...(dto.dayNumber !== undefined && { dayNumber: dto.dayNumber }),
        ...(dto.date !== undefined && { date: dto.date }),
        ...(dto.title !== undefined && { title: dto.title }),
        ...(dto.notes !== undefined && { notes: dto.notes }),
        ...(dto.sequenceOrder !== undefined && { sequenceOrder: dto.sequenceOrder }),
        updatedAt: new Date(),
      })
      .where(eq(this.db.schema.itineraryDays.id, id))
      .returning()

    return this.formatDayResponse(day)
  }

  /**
   * Delete a day (cascade deletes all activities)
   * Also renumbers remaining days to maintain sequential dayNumbers
   */
  async remove(id: string): Promise<void> {
    // Get the day to be deleted (need itineraryId and dayNumber for renumbering)
    const dayToDelete = await this.findOne(id)

    // Delete the day
    await this.db.client
      .delete(this.db.schema.itineraryDays)
      .where(eq(this.db.schema.itineraryDays.id, id))

    // Renumber remaining days with dayNumber > deleted dayNumber
    // Get all days that need renumbering
    const daysToRenumber = await this.db.client
      .select()
      .from(this.db.schema.itineraryDays)
      .where(
        and(
          eq(this.db.schema.itineraryDays.itineraryId, dayToDelete.itineraryId),
          // gt not available, use SQL expression: dayNumber > deletedDayNumber
        )
      )
      .orderBy(asc(this.db.schema.itineraryDays.dayNumber))

    // Filter to days with higher dayNumber and decrement
    const updates = daysToRenumber
      .filter((d) => d.dayNumber > dayToDelete.dayNumber)
      .map((day) =>
        this.db.client
          .update(this.db.schema.itineraryDays)
          .set({
            dayNumber: day.dayNumber - 1,
            title: day.title?.startsWith('Day ')
              ? `Day ${day.dayNumber - 1}`
              : day.title, // Update auto-generated titles
            updatedAt: new Date(),
          })
          .where(eq(this.db.schema.itineraryDays.id, day.id))
      )

    if (updates.length > 0) {
      await Promise.all(updates)
    }
  }

  /**
   * Reorder days (drag-and-drop)
   */
  async reorder(itineraryId: string, dto: ReorderDaysDto): Promise<ItineraryDayResponseDto[]> {
    // Verify all day IDs belong to this itinerary
    const dayIds = dto.dayOrders.map((d: { id: string; sequenceOrder: number }) => d.id)
    const days = await this.db.client
      .select()
      .from(this.db.schema.itineraryDays)
      .where(
        and(
          eq(this.db.schema.itineraryDays.itineraryId, itineraryId),
          inArray(this.db.schema.itineraryDays.id, dayIds)
        )
      )

    if (days.length !== dayIds.length) {
      throw new BadRequestException('One or more day IDs are invalid or do not belong to this itinerary')
    }

    // Update sequence orders
    await Promise.all(
      dto.dayOrders.map((order: { id: string; sequenceOrder: number }) =>
        this.db.client
          .update(this.db.schema.itineraryDays)
          .set({
            sequenceOrder: order.sequenceOrder,
            updatedAt: new Date(),
          })
          .where(eq(this.db.schema.itineraryDays.id, order.id))
      )
    )

    // Return updated days
    return this.findAll(itineraryId)
  }

  /**
   * Auto-generate days from trip start/end dates
   */
  async autoGenerate(dto: AutoGenerateDaysDto): Promise<ItineraryDayResponseDto[]> {
    // Get itinerary and trip information
    const [itinerary] = await this.db.client
      .select()
      .from(this.db.schema.itineraries)
      .where(eq(this.db.schema.itineraries.id, dto.itineraryId))
      .limit(1)

    if (!itinerary || !itinerary.agencyId) {
      throw new NotFoundException(`Itinerary with ID ${dto.itineraryId} not found or has no agency`)
    }

    const agencyId = itinerary.agencyId

    const [trip] = await this.db.client
      .select()
      .from(this.db.schema.trips)
      .where(eq(this.db.schema.trips.id, itinerary.tripId))
      .limit(1)

    // Prefer itinerary dates, fall back to trip dates
    const effectiveStartDate = itinerary.startDate || trip?.startDate
    const effectiveEndDate = itinerary.endDate || trip?.endDate

    if (!effectiveStartDate || !effectiveEndDate) {
      throw new BadRequestException('Itinerary or trip must have start and end dates to auto-generate days')
    }

    // Calculate number of days
    const startDate = new Date(effectiveStartDate)
    const endDate = new Date(effectiveEndDate)
    const dayCount = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)) + 1

    // Delete existing days for this itinerary
    await this.db.client
      .delete(this.db.schema.itineraryDays)
      .where(eq(this.db.schema.itineraryDays.itineraryId, dto.itineraryId))

    const daysToCreate: Array<{
      agencyId: string
      itineraryId: string
      dayNumber: number
      date?: string
      title: string
      sequenceOrder: number
    }> = []

    // Create pre-travel day if requested
    if (dto.includePreTravelDay) {
      daysToCreate.push({
        agencyId,
        itineraryId: dto.itineraryId,
        dayNumber: 0,
        title: 'Pre-Travel Information',
        sequenceOrder: 0,
      })
    }

    // Create days for each day of the trip
    // Use UTC methods consistently to avoid timezone offset issues
    for (let i = 0; i < dayCount; i++) {
      const currentDate = new Date(startDate)
      currentDate.setUTCDate(startDate.getUTCDate() + i)

      daysToCreate.push({
        agencyId,
        itineraryId: dto.itineraryId,
        dayNumber: i + 1,
        date: currentDate.toISOString().split('T')[0], // YYYY-MM-DD
        title: `Day ${i + 1}`,
        sequenceOrder: dto.includePreTravelDay ? i + 1 : i,
      })
    }

    // Insert all days
    const created = await this.db.client
      .insert(this.db.schema.itineraryDays)
      .values(daysToCreate)
      .returning()

    return created.map(this.formatDayResponse)
  }

  /**
   * Batch create multiple days
   * Supports both count mode (N dateless/dated days) and date range mode
   * Position 'start' inserts days at the beginning and renumbers existing days
   * Position 'end' (default) appends days after existing days
   */
  async batchCreate(
    itineraryId: string,
    dto: BatchCreateDaysDto
  ): Promise<ItineraryDayResponseDto[]> {
    const position = dto.position || 'end'

    // Validate: either count OR date range must be provided
    const hasCount = dto.count !== undefined && dto.count > 0
    const hasDateRange = dto.startDate && dto.endDate

    if (!hasCount && !hasDateRange) {
      throw new BadRequestException('Either count or startDate/endDate must be provided')
    }

    // Position 'start' only supports count mode (not date range)
    if (position === 'start' && hasDateRange) {
      throw new BadRequestException('Date range mode is not supported when adding days at start')
    }

    // Enforce 30-day batch limit
    if (hasCount && dto.count! > 30) {
      throw new BadRequestException('Batch limit exceeded (max 30 days)')
    }

    // Verify itinerary exists and get trip info
    const [itinerary] = await this.db.client
      .select()
      .from(this.db.schema.itineraries)
      .where(eq(this.db.schema.itineraries.id, itineraryId))
      .limit(1)

    if (!itinerary || !itinerary.agencyId) {
      throw new NotFoundException(`Itinerary with ID ${itineraryId} not found or has no agency`)
    }

    // Get trip for date bounds validation
    const [trip] = await this.db.client
      .select()
      .from(this.db.schema.trips)
      .where(eq(this.db.schema.trips.id, itinerary.tripId))
      .limit(1)

    const tripStartDate = itinerary.startDate || trip?.startDate
    const tripEndDate = itinerary.endDate || trip?.endDate

    // Get existing days to determine starting dayNumber and sequenceOrder
    const existingDays = await this.findAll(itineraryId)

    // Handle position='start' - prepend days and renumber existing
    if (position === 'start') {
      return this.batchCreateAtStart(
        itineraryId,
        itinerary.agencyId,
        dto.count!,
        existingDays,
        tripStartDate
      )
    }

    // Position='end' - append days after existing (original behavior)
    const maxDayNumber = existingDays.length > 0
      ? Math.max(...existingDays.map((d) => d.dayNumber))
      : 0
    const maxSequenceOrder = existingDays.length > 0
      ? Math.max(...existingDays.map((d) => d.sequenceOrder))
      : -1

    // Find last dated day (for continuation and overlap validation)
    const datedDays = existingDays.filter((d) => d.date).sort((a, b) =>
      new Date(a.date!).getTime() - new Date(b.date!).getTime()
    )
    const lastDatedDay = datedDays.length > 0 ? datedDays[datedDays.length - 1] : null
    const lastDate = lastDatedDay?.date ? new Date(lastDatedDay.date) : null

    // Build days to create (include agencyId from parent itinerary)
    const agencyId = itinerary.agencyId
    const daysToCreate: Array<{
      agencyId: string
      itineraryId: string
      dayNumber: number
      date: string | null
      title: string
      sequenceOrder: number
    }> = []

    if (hasDateRange) {
      // Date range mode
      const startDate = new Date(dto.startDate!)
      const endDate = new Date(dto.endDate!)

      // Validate: start <= end
      if (startDate > endDate) {
        throw new BadRequestException('Start date must be before or equal to end date')
      }

      // Validate: dates within trip bounds (if trip has dates)
      if (tripStartDate && startDate < new Date(tripStartDate)) {
        throw new BadRequestException('Date range must be within trip dates')
      }
      if (tripEndDate && endDate > new Date(tripEndDate)) {
        throw new BadRequestException('Date range must be within trip dates')
      }

      // Validate: start date > last existing dated day (no overlap)
      if (lastDate && startDate <= lastDate) {
        const lastDateStr = lastDate.toISOString().split('T')[0]
        throw new BadRequestException(
          `Date range must start after last day (${lastDateStr})`
        )
      }

      // Calculate day count from date range
      const rangeDayCount = Math.ceil(
        (endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)
      ) + 1

      // Enforce 30-day limit on date range too
      if (rangeDayCount > 30) {
        throw new BadRequestException('Batch limit exceeded (max 30 days)')
      }

      for (let i = 0; i < rangeDayCount; i++) {
        const currentDate = new Date(startDate)
        currentDate.setDate(startDate.getDate() + i)
        const dateStr = currentDate.toISOString().split('T')[0]!
        const dayNum = maxDayNumber + i + 1

        daysToCreate.push({
          agencyId,
          itineraryId,
          dayNumber: dayNum,
          date: dateStr,
          title: `Day ${dayNum}`,
          sequenceOrder: maxSequenceOrder + i + 1,
        })
      }
    } else {
      // Count mode
      for (let i = 0; i < dto.count!; i++) {
        const dayNum = maxDayNumber + i + 1
        let dateStr: string | null = null

        // If last existing day has a date, continue the sequence
        if (lastDate) {
          const newDate = new Date(lastDate)
          newDate.setDate(lastDate.getDate() + i + 1)

          // If trip has end date, don't go past it
          if (tripEndDate && newDate > new Date(tripEndDate)) {
            // Create dateless day instead
            dateStr = null
          } else {
            dateStr = newDate.toISOString().split('T')[0]!
          }
        }

        daysToCreate.push({
          agencyId,
          itineraryId,
          dayNumber: dayNum,
          date: dateStr,
          title: `Day ${dayNum}`,
          sequenceOrder: maxSequenceOrder + i + 1,
        })
      }
    }

    // Bulk insert all days in a single transaction
    const created = await this.db.client
      .insert(this.db.schema.itineraryDays)
      .values(daysToCreate)
      .returning()

    return created.map(this.formatDayResponse)
  }

  /**
   * Batch create days at the START of an itinerary
   * - Calculates dates going backwards from first existing dated day
   * - Shifts existing days' dayNumber and sequenceOrder by count
   * - Uses transaction for atomicity
   */
  private async batchCreateAtStart(
    itineraryId: string,
    agencyId: string,
    count: number,
    existingDays: ItineraryDayResponseDto[],
    tripStartDate: string | null | undefined
  ): Promise<ItineraryDayResponseDto[]> {
    // Find first dated day (sorted by date ascending)
    const datedDays = existingDays
      .filter((d) => d.date)
      .sort((a, b) => new Date(a.date!).getTime() - new Date(b.date!).getTime())
    const firstDatedDay = datedDays.length > 0 ? datedDays[0] : null
    const firstDate = firstDatedDay?.date ? new Date(firstDatedDay.date) : null

    // Build days to create (dayNumber 1..count, sequenceOrder 0..count-1)
    const daysToCreate: Array<{
      agencyId: string
      itineraryId: string
      dayNumber: number
      date: string | null
      title: string
      sequenceOrder: number
    }> = []

    for (let i = 0; i < count; i++) {
      const dayNum = i + 1
      let dateStr: string | null = null

      // If existing days have dates, calculate dates going backwards
      if (firstDate) {
        const newDate = new Date(firstDate)
        // For count=3: i=0 gets firstDate-3, i=1 gets firstDate-2, i=2 gets firstDate-1
        newDate.setDate(firstDate.getDate() - (count - i))
        dateStr = newDate.toISOString().split('T')[0]!

        // Validate: new date must not be before trip start date
        if (tripStartDate) {
          const tripStart = new Date(tripStartDate)
          if (newDate < tripStart) {
            const tripStartStr = tripStart.toISOString().split('T')[0]
            throw new BadRequestException(
              `Cannot add ${count} days before trip start date (${tripStartStr}). ` +
              `The earliest date would be ${dateStr}.`
            )
          }
        }
      }

      daysToCreate.push({
        agencyId,
        itineraryId,
        dayNumber: dayNum,
        date: dateStr,
        title: `Day ${dayNum}`,
        sequenceOrder: i,
      })
    }

    // Use transaction: shift existing days FIRST, then insert new days
    const created = await this.db.client.transaction(async (tx) => {
      // Step 1: Shift all existing days' dayNumber and sequenceOrder by count
      if (existingDays.length > 0) {
        await tx
          .update(this.db.schema.itineraryDays)
          .set({
            dayNumber: sql`${this.db.schema.itineraryDays.dayNumber} + ${count}`,
            sequenceOrder: sql`${this.db.schema.itineraryDays.sequenceOrder} + ${count}`,
            updatedAt: new Date(),
          })
          .where(eq(this.db.schema.itineraryDays.itineraryId, itineraryId))
      }

      // Step 2: Insert new days at the start
      const inserted = await tx
        .insert(this.db.schema.itineraryDays)
        .values(daysToCreate)
        .returning()

      return inserted
    })

    return created.map(this.formatDayResponse)
  }

  // ============================================================================
  // Helper Methods
  // ============================================================================

  private formatDayResponse(day: any): ItineraryDayResponseDto {
    return {
      ...day,
      date: day.date || null,
      title: day.title || null,
      notes: day.notes || null,
      createdAt: day.createdAt.toISOString(),
      updatedAt: day.updatedAt.toISOString(),
    }
  }

  private async getMaxSequenceOrder(itineraryId: string): Promise<number> {
    const [result] = await this.db.client
      .select({
        maxSeq: this.db.schema.itineraryDays.sequenceOrder,
      })
      .from(this.db.schema.itineraryDays)
      .where(eq(this.db.schema.itineraryDays.itineraryId, itineraryId))
      .orderBy(desc(this.db.schema.itineraryDays.sequenceOrder))
      .limit(1)

    return result?.maxSeq ?? -1
  }
}
